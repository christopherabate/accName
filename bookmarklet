javascript:(function() {
  function accName(element) {
    /**
     * Determines if an element is visible by checking its styles and aria-hidden attribute.
     * Uses recursion to check all parent elements.
     * @param {HTMLElement} element - The element to check.
     * @returns {boolean} - True if the element and its ancestors are visible.
     */
    const isVisible = (element) => {
      if (!element) return true;
      const computedStyle = getComputedStyle(element);
      if (computedStyle.visibility === 'hidden' || computedStyle.display === 'none' || element.closest('[aria-hidden="true"]')) {
        return false;
      }
      return isVisible(element.parentElement);
    };

    /**
     * Recursively collects visible text content from the element and its children.
     * @param {HTMLElement} element - The element to retrieve content from.
     * @returns {string} - The visible content as a trimmed string.
     */
    const getVisibleContent = (element) => {
      if (!isVisible(element)) return '';
      
      const textNodes = [...element.childNodes]
        .filter(node => node.nodeType === Node.TEXT_NODE)
        .map(node => node.textContent.trim())
        .join(' ');

      const childrenContent = [...element.children]
        .map(getVisibleContent)
        .filter(Boolean)
        .join(' ');

      return [textNodes, childrenContent].join(' ').trim();
    };

    /**
     * Retrieves visible labels from a given selector.
     * @param {string} selector - The CSS selector to match labels.
     * @returns {string} - The concatenated visible label content.
     */
    const getVisibleLabels = (selector) => {
      return [...element.ownerDocument.querySelectorAll(selector)]
        .filter(isVisible)
        .map(label => label.textContent.trim())
        .join(', ');
    };

    // Collects accessible name sources
    const ariaLabels = getVisibleLabels(`#${element.getAttribute('aria-labelledby')?.split(' ').join(', #')}`);
    const ariaLabel = element.getAttribute('aria-label')?.trim();
    const labelForElement = getVisibleLabels(`label[for="${element.id}"]`);
    const closestLabel = element.closest('label')?.textContent.trim();
    const altText = element.hasAttribute('alt') ? element.getAttribute('alt')?.trim() : null;
    const figcaption = element.closest('figure')?.querySelector('figcaption')?.textContent.trim();
    const caption = element.closest('table')?.querySelector('caption')?.textContent.trim();
    const legend = element.closest('fieldset')?.querySelector('legend')?.textContent.trim();
    const title = element.getAttribute('title')?.trim();
    const placeholder = element.getAttribute('placeholder')?.trim();
    const textContent = getVisibleContent(element)?.trim();

    // Return the first non-empty value in priority order
    return {
      ariaLabels,
      ariaLabel,
      labelForElement,
      closestLabel,
      altText,
      figcaption,
      caption,
      legend,
      title,
      placeholder,
      textContent
    };
  }

  // Fonction pour tronquer le texte à 120 caractères
  function truncateText(text, maxLength = 120) {
    return text.length > maxLength ? text.slice(0, maxLength) + '...' : text;
  }
  
  // Créer un div racine pour encapsuler le tooltip
  const tooltipContainer = document.createElement('div');
  document.body.appendChild(tooltipContainer);

  // Utiliser Shadow DOM pour encapsuler le style du tooltip
  const shadowRoot = tooltipContainer.attachShadow({ mode: 'open' });
  
  // Créer l'encadré (tooltip) draggable
  const tooltip = document.createElement('div');
  tooltip.style.position = 'fixed';
  tooltip.style.top = '10px';
  tooltip.style.left = '10px';
  tooltip.style.width = '300px';
  tooltip.style.backgroundColor = 'yellow';
  tooltip.style.border = '1px solid black';
  tooltip.style.padding = '10px';
  tooltip.style.zIndex = '10000';
  tooltip.style.cursor = 'move';
  tooltip.style.userSelect = 'none'; // Désactiver la sélection de texte pendant le drag
  shadowRoot.appendChild(tooltip);
  
  // Ajouter le bouton de fermeture (croix)
  const closeButton = document.createElement('span');
  closeButton.innerHTML = '&times;';
  closeButton.style.position = 'absolute';
  closeButton.style.top = '5px';
  closeButton.style.right = '10px';
  closeButton.style.cursor = 'pointer';
  closeButton.style.fontSize = '16px';
  closeButton.style.fontWeight = 'bold';
  closeButton.style.color = '#333';
  tooltip.appendChild(closeButton);

  // Fonction pour fermer le tooltip
  closeButton.addEventListener('click', function() {
    tooltip.style.display = 'none';
  });

  // Ajouter la fonctionnalité de déplacement (draggable)
  let isDragging = false;
  let offsetX, offsetY;

  tooltip.addEventListener('mousedown', function(e) {
    isDragging = true;
    offsetX = e.clientX - tooltip.offsetLeft;
    offsetY = e.clientY - tooltip.offsetTop;
  });

  document.addEventListener('mousemove', function(e) {
    if (isDragging) {
      tooltip.style.left = (e.clientX - offsetX) + 'px';
      tooltip.style.top = (e.clientY - offsetY) + 'px';
    }
  });

  document.addEventListener('mouseup', function() {
    isDragging = false;
  });

  // Ajouter un écouteur de survol de la souris
  document.addEventListener('mouseover', function(event) {
    const element = event.target;
    
    // Empêcher l'action si la souris est sur l'encadré (tooltip) ou un de ses descendants
    if (tooltip.contains(element)) return;

    // Ignorer les éléments de type spécifié dans ignoredTags
    if (['div', 'html', 'body'].includes(element.tagName.toLowerCase())) return;

    const name = accName(element);

    // Récupérer le tagName, l'ID et la classe de l'élément
    const tagName = element.tagName.toLowerCase();
    const elementID = element.id ? `#${element.id}` : '';
    const elementClass = element.className ? `.${[...element.classList].join('.')}` : '';

    // Formater les résultats de manière lisible
    tooltip.innerHTML = `
      <strong>${tagName}${elementID}${elementClass}:</strong><br/>
      <ul>
        ${Object.keys(name).map(key => 
          name[key] ? `<li><strong>${key}:</strong> ${truncateText(name[key])}</li>` : ''
        ).join('')}
      </ul>
    `;
    tooltip.appendChild(closeButton); // Ré-ajout de la croix après modification du contenu
  });

  // Cacher l'encadré lorsqu'aucun élément n'est survolé
  document.addEventListener('mouseout', function() {
    tooltip.innerHTML = '<strong>Survolez un élément pour voir son nom accessible</strong>';
    tooltip.appendChild(closeButton); // Ré-ajout de la croix après modification du contenu
  });

  // Message initial dans l'encadré
  tooltip.innerHTML = '<strong>Survolez un élément pour voir son nom accessible</strong>';
  tooltip.appendChild(closeButton); // Ré-ajout de la croix après modification du contenu
  
  // Ajouter un style de base à l'intérieur du Shadow DOM pour garantir l'isolation
  const style = document.createElement('style');
  style.textContent = `
    div {
      font-family: Arial, sans-serif;
      color: black;
      font-size: 14px;
      line-height: 1.5;
    }
    strong {
      font-weight: bold;
    }
    ul {
      list-style: none;
      padding-left: 0;
    }
    li {
      margin-bottom: 5px;
    }
  `;
  shadowRoot.appendChild(style);
})();
